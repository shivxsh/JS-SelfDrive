1) Build the road like initial structure by using the canvas in html and aligning it to the center with width 200

2) Create a new "Car"  class in car.js (steps explained in that file.)
   Call that car object from main.js
   ctx stores the context of the canvas, which will be the parameter taken by the "draw()" method

3) Movement of the car : 
    create a controls.js file.
    make a new class called controls with a constructor

4) Inside the controls file, we used a private method called keyboard listener.
   Inside this method, we used "onkeydown" and "onkeyup" methods to check if the key is pressed or is it released.
   While it is pressed, we set the respective key values declared inside of the constructor as true. (By default we declared it as false)

5) The Y-axis  increases as it goes down on a computer.
   Hence, to show these changes on the screen, we move the canvas y-2 times for the card to move forward and
   y+2 times for it to move down.
   //This is the initial plan. Before implementing the speed and acceleration and stopping mechanisms.

6) To make this work, we use an "animate()" function in main.js
   It basically uses the "requestAnimationFrame()" method that repeatedly calls the animate method.
   This method calls the update() method and draw(context) method.

7) Now, we need to make the car move with a certain speed and acceleration. Also introduce friction to stop the car.
   Instead of doing Y-2 and Y+2 in step-5; We can now add acceleration with speed and subtract it for moving forward and backward.

    For the left and right movement, we need to "rotate" the car. For that, we introduce a variable called "angle"
    For every left and right key press, we use the translate() method to rotate the car 0.03 degrees anticlockwise.

8) Now, we move the car left and right based on sin and cos angles respectively. sin function for the x axis and cos for y axis.
   Since the entire idea of the car is based on a unit circle, we have used the sin and cos functions for rotating the car in left and right directions.
   Inorder to have the reverse direction work in the same exact way and not get inverted, we introduce a "flip" variable that basically gets assigned the value
   of -1 if car is going in reverse else it is 1. Now when it is -1, the left and right rotation angles are multiplied by flip so that the direction is inverted and 
   hence now, the car moves in the correct direction.

// Defining the road:
9) moveTo() method moves the canvas to a specified point.
   lineTo() adds a point to which the canvas can draw a line to FROM the last point.
   Note that, both of these above functions do NOT draw a line. Hence we use a "stroke()" function to draw a line.

   Our Road class inside road.js takes a constructor with the parameters : "x coordinate", "Width", and "laneCount" which is set to 3 by default
   
10) We use the LERP (linear interpollation) function to get the distance between the initial and next position of the object.
    function lerp(A,B,t) => { return A + (B-A)*t}, where t is the value between 0 and 1 got from the loop of i=0 and i<= laneCount where t = i/laneCount;

11) To add the dashed lines on the road we use the .setLineDash([param-1, param-2]); where param-1 will be the size of the line and param-2 will be the break between 2 lines.

12) Next, we need to find the center of the car for a given set of lanes.
    For this, we define a " function getLaneCenter(laneIndex) " that will get the lane index (numbering of lanes starting from 0) as an argument and return the 
    return the center of the particular lane. Hence the car will always start at the center of the specified lane.

13) Now, to make sure our car doesnt go off the side and make our road side margins stop the car from moving outside,  we add a field in our road constructor  "borders[]"
    which takes in a set of segments (topLeft, bottomLeft, topRight, bottomRight). where x:this.left/this.right and y:this.top/this.bottom

14) To pin the camera view on the car, we use " ctx.translate(0,-car.y + canvas.height*0.8); "  in the main.js file such that it feels like the road is moving infinitely.

//Now to add the sensors : 
15) We use rays with ray length = 100px, ray spread = pi/4 or 45 deg and rayLines = 3 (initially set to 3)

16) Note that we use a unit circle rotated to the left for refernce of the sin and cos angles. Hence the sensor rays move in a sin angle in x axis and cosine angle in the y axis.
    This is done using the const start and end variables inside the sensor.js file.

17)Now, inorder to move our sensors along with the car, we add the "this.car.angle" along with the lerp function of the rays inside sensors.js such that whenever the car moves, the rays
   also move along with it. 360 degrees rays? sure, use " Math.PI * 2 ". But this depends on your preference.

18) Now we need to check whether our sensors detect something. For this, we declare an array called readings inside which we push the rays and roadBorders by using a custom function called 
    "getReading(rays,roadBorders)". The idea is to simulate the touches of the rays to a border and push the "closest" touch inside the readings array. 
    i.e. consider a single ray passing from the car, hence now if the car is turning left and it detects another car approaching from the other side, then the ray will detect two things in its path :
    #1 is the other car that is approaching 
    #2 the road border that is beyond the car. Now the closest object to the ray is the car and hence it will push the touch of the car inside the reading array.

19) The getIntersection() method : takes 4 points (A,B,C,D). Where AB and CD are two line segments. The tTop and uTop are the numerators and bottom is the denominator. The t and u are the parameters that decide 
    if there is an intersection in the line segments. Consider the line segment as A and A+r ; C and C+s. Then a point on these line segments will be at A+tr or at C+us, where t and u are some scalars.
    The code checkes if the bottom is 0 (i.e. if denominator is zero. If numerator != 0 denominator = 0, then line is parallel. No intersection.) Thus, if there is an intersection, and the points lie on the line segment,
    the function returns 3 values : x,y and offset. where x is the lerp function of A and B's x coordinates and y is the lerp funciton of A and B's y coordinates. The offset is the distance between the car and the object.

//Collision detection : 
20) Inorder to simulate the damages suffered in our car, we need to somehow find the coordinates of the "border" of our car. For this, we go to car.js and define a function called "createPolygon". It takes in an array of points [].
    One for each corner of the car. 
    Inside the car's rectangle from the center point : we have a right triangle whose distance to the 4 corners from the center is just the hypotenuse of the right triangle. (triangle  : from centre point -> any corner -> point horizontally parallel to center)

21) So, our radius will be " Math.hypot(height,width)/2 "; Why /2 ? Bcos we need to stop at the center for our right traingle.
    Our angle at the center point will be " const alpha  = atan2(width, height); " ; atan2 is arc-tan : It determine the value of an angle in a right triangle.
    Notice how we didnt use (height,width)/2 here? Because angle will be the same regardless.

22) We push the x and y coordinates of the 4 edges of the car into the points[] array. Note that the 3rd and 4th points are basically located 180 deg opposite to the frist 2 points. Hence just add 180 deg (Math.Pi) to it.

23) With this, we can rewrite our " draw(ctx) " method by making a line to the array of points every time we move the car.

24) Now to know if our car hits an object or not : 
   -> Create a function called polyIntersect() in utils.js   
   -> This will basically take up two parameters : The edges of the car & road Borders (for now, since we are yet to add traffic)
   -> Inside the function we check if there is an intersection between the two polygons by calling the getIntersection method declared earlier.
   -> It returns true if there is a intersection and false if there is not.

25) Hence, if it is damaged : 
   -> we dont allow it to move!  Under the update(roadBorders) methiod in car.js : we introduce a simple if statement i.e. (if (! this.damaged){ //allow all operations to be done } )

//Adding Traffic : 
26) In main.js we simulate traffic by creating an array of car objects.
    Next in out animate section, we go through each car in the traffic array and update our road.
    And we also get the context and draw it as we go through each car in the array

** Problem faced** : When in tested it by adding one car, our keyboard listeners will be over written. Hence we will no longer be able to control our car, but the newly added car.
   TO resolve this : 
    1) We distinguish between the two cars : "DUMMY" and "KEYS"
    2) We add the keyboard listening functions to the "KEYS" and if the car is a "DUMMY" we just set " this.forward = true " 
    3) How do we know a car is "KEYS" or "DUMMY" ? ==> We create a new field in the car constructor called "controlType" in which we pass the value "DUMMY" or "KEYS while creating an instance of the car object
    4) To avoid the speeds of the two cars being different, we also add a " maxSpeed = 2 " inside the constructor to set the default speed of the dummy cars.
    5) To avoid the sensor lines being projected from the other car we add a condition inside update(roadBorders) to only update the sensor if the car is a DUMMY.

Next we need to interact with the traffic. When our car hits the car from traffic array, we need to make our car damage and stop. Hene we use the assessDamage function that is inside the car.js file and just as it updates 
with the road borders we make it updated with the traffic cars inside the array.

Next we need to update the sensors to detect the cars.
Just like how it detects road borders we make it detect the cars infront using getIntersection function.

//Adding Neural Networks : 
1) Imagine NN like levels. Each level has a floor, a ceiling and lot of connections between the floor and ceiling. The ceiling of level 1 is the floor of level 2 adn so on.

2) So, we define a level class : 
    -> input Node counts
    -> output Node counts
    -> biases
    -> weights

3) Initally we set the weights and biases as random for every node.

4) We compute the output using a feedForward algorithm :
   A feedForward NN is an " artificial neural network ". All information is only passed forward. 
   During data flow, input nodes receive data, which travel through hidden layers, and exit output nodes. 

5) So NN basic calculations are performed here as well : 
   -> The inputs are what we get from the sensors, i.e. do they touch/ detect something or not
   -> The calculation will be input * weight at that node.
   -> The sum of all the (input * weight) will give the value of the outputs.
        -> But, if the sum is < than bias we set output neuron to 1 (ON)
        -> else, if sum > bias, we set output neueon to 0. (OFF)

   -> Implement the feedForward function that will 

6) Now that we have implemented our Level class, we basically create another class called "Neural Network" for adding more levels.
   -> This is done by creating an empty array of levels in which we push a new Level object with 2 parameters : input neuron counts and output neuron counts.
   -> And we use a feed forward method which returns the output for those levels.

7) Integrating the NN function with our code :
    -> Inside car.js we create object of Neural Network which takes in rayCount, Hidden Layers, and output layers (4 : up, down, left, right) as inputs.
    -> Next we need to tell our car that an object is far away or its close by : 
        Which we do by updating the sensor offset values to low values if an object is far by and high value when object is close

8) Next make our car run by itself : 
    -> We set this.useBrain inside our car constructor to the brian variable that stores the NN object.
    -> The sensors are updated such that based on the output values returned by the NN, it uses the controls.js 's forward/reverse/left/right functionality 
       and moves in a random direction.

9) Now time for Parallelization or Generating More cars that do random things as accordingly by the random assignment of weights.
    This is done by pusing car objects into a cars array for N times. Thus resulting in a lot of cars driving random directions based on the NN.

//FITNESS Function : (our fitness function is the min y value but there are a lot of other functions that can also be used to find our goal)
10) We want to focus on the "BEST" car.... i.e. the one that goes up the most. Inorder to do that :
    -> The best car that goes the farthest upwards is the car with the "Minimum y value". Since, in a computer the y axis increases downwards.
    -> To find the min y value, we basically have an array of all y values of the new generated cars and only search for the minimum values using the "Spread ... Operator"
    -> Thus, by using the find() method which eturns the value of the first element that passes a test, we set the bestCar to be the one with minimum y value and it will be focussed as it's object will only be highlighted in a different color.

11) Now save the progress of the learning made by the car : (otherwise when u close ur vs code, all the learning done will be lost) 
    -> We create a save() function that will save the learnings made by the car in our localStorage :
        -> localStorage object allows you to save key/value pairs in the browser.
        -> stores data with no expiration date. The data is not deleted when the browser is closed, and are available for future sessions.
        -> Thus to counter the above, we created a "discard()" method that removes the bestCar's learning from localStorage.
        
        -> ** NOTE : **    We can ONLY store STRINGS in the window.localStorage object.
        -> JSON.stringify method converts any object or acceptable value into a string JSON
    
12) Now add more cars inside the traffic array to simulate traffic.

13) Mutate function : 


14) 
