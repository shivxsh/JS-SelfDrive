1) Build the road like initial structure by using the canvas in html and aligning it to the center with width 200

2) Create a new "Car"  class in car.js (steps explained in that file.)
   Call that car object from main.js
   ctx stores the context of the canvas, which will be the parameter taken by the "draw()" method

3) Movement of the car : 
    create a controls.js file.
    make a new class called controls with a constructor

4) Inside the controls file, we used a private method called keyboard listener.
   Inside this method, we used "onkeydown" and "onkeyup" methods to check if the key is pressed or is it released.
   While it is pressed, we set the respective key values declared inside of the constructor as true. (By default we declared it as false)

5) The Y-axis  increases as it goes down on a computer.
   Hence, to show these changes on the screen, we move the canvas y-2 times for the card to move forward and
   y+2 times for it to move down.
   //This is the initial plan. Before implementing the speed and acceleration and stopping mechanisms.

6) To make this work, we use an "animate()" function in main.js
   It basically uses the "requestAnimationFrame()" method that repeatedly calls the animate method.
   This method calls the update() method and draw(context) method.

7) Now, we need to make the car move with a certain speed and acceleration. Also introduce friction to stop the car.
   Instead of doing Y-2 and Y+2 in step-5; We can now add acceleration with speed and subtract it for moving forward and backward.

    For the left and right movement, we need to "rotate" the car. For that, we introduce a variable called "angle"
    For every left and right key press, we use the translate() method to rotate the car 0.03 degrees anticlockwise.

8) Now, we move the car left and right based on sin and cos angles respectively. sin function for the x axis and cos for y axis.
   Since the entire idea of the car is based on a unit circle, we have used the sin and cos functions for rotating the car in left and right directions.
   Inorder to have the reverse direction work in the same exact way and not get inverted, we introduce a "flip" variable that basically gets assigned the value
   of -1 if car is going in reverse else it is 1. Now when it is -1, the left and right rotation angles are multiplied by flip so that the direction is inverted and 
   hence now, the car moves in the correct direction.

// Defining the road:
9) moveTo() method moves the canvas to a specified point.
   lineTo() adds a point to which the canvas can draw a line to FROM the last point.
   Note that, both of these above functions do NOT draw a line. Hence we use a "stroke()" function to draw a line.

   Our Road class inside road.js takes a constructor with the parameters : "x coordinate", "Width", and "laneCount" which is set to 3 by default
   
10) We use the LERP (linear interpollation) function to get the distance between the initial and next position of the object.
    function lerp(A,B,t) => { return A + (B-A)*t}, where t is the value between 0 and 1 got from the loop of i=0 and i<= laneCount where t = i/laneCount;

11) To add the dashed lines on the road we use the .setLineDash([param-1, param-2]); where param-1 will be the size of the line and param-2 will be the break between 2 lines.

12) Next, we need to find the center of the car for a given set of lanes.
    For this, we define a " function getLaneCenter(laneIndex) " that will get the lane index (numbering of lanes starting from 0) as an argument and return the 
    return the center of the particular lane. Hence the car will always start at the center of the specified lane.

13) Now, to make sure our car doesnt go off the side and make our road side margins stop the car from moving outside,  we add a field in our road constructor  "borders[]"
    which takes in a set of segments (topLeft, bottomLeft, topRight, bottomRight). where x:this.left/this.right and y:this.top/this.bottom

14) To pin the camera view on the car, we use " ctx.translate(0,-car.y + canvas.height*0.8); "  in the main.js file such that it feels like the road is moving infinitely.

//Now to add the sensors : 
15) We use rays with ray length = 100px, ray spread = pi/4 or 45 deg and rayLines = 3 (initially set to 3)

16) Note that we use a unit circle rotated to the left for refernce of the sin and cos angles. Hence the sensor rays move in a sin angle in x axis and cosine angle in the y axis.
    This is done using the const start and end variables inside the sensor.js file.

17)Now, inorder to move our sensors along with the car, we add the "this.car.angle" along with the lerp function of the rays inside sensors.js such that whenever the car moves, the rays
   also move along with it. 360 degrees rays? sure, use " Math.PI * 2 ". But this depends on your preference.

18) Now we need to check whether our sensors detect something. For this, we declare an array called readings inside which we push the rays and roadBorders by using a custom function called 
    "getReading(rays,roadBorders)". The idea is to simulate the touches of the rays to a border and push the "closest" touch inside the readings array. 
    i.e. consider a single ray passing from the car, hence now if the car is turning left and it detects another car approaching from the other side, then the ray will detect two things in its path :
    1) is the other car that is approaching and 2) is the road border that is beyond the car. Now the closest object to the ray is the car and hence it will push the touch of the car inside the reading array.

19) The getIntersection() method : takes 4 points (A,B,C,D). Where AB is a line segment and CD is a line segment. 